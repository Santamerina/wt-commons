#summary TestSuiteBuilder is a way to use Eclipse's plugin extensions to build JUnit TestSuites declaratively in an XML file.

= Introduction to TestSuiteBuilder =

TestSuiteBuilder is a way to use Eclipse's plugin extensions to build JUnit TestSuites declaratively in an XML file. It is a class defined in the org.wtc.eclipse.core Helper Library plugin. See [http://wt-commons.googlecode.com/svn/docs/html/reference/javadoc/helper-libs/org/wtc/eclipse/core/tsb/TestSuiteBuilder.html TestSuiteBuilder], though this class should only be referred to in JUnit test runner arguments and not programatically (this class is not meant to be subclassed). 

Why build TestSuites programatically? For large Eclipse projects, tests are often split out by plugin but should be part of the same JUnit TestSuite. As an example, let's assume I have two teams working on components for the same Eclipse feature. In this scenario, the teams each work within their own modules in source, each with their own production plugin and accompanying test plugin:
{{{
project/
   moduleA/
      src/
          plugins/
              project.example.modulea/
      test/
          plugins/
              project.example.modulea.test/
   moduleB/
      src/
          plugins/
              project.example.moduleb/
      test/
          plugins/
              project.example.moduleb.test/
}}}

The teams chose to split the production code and test code into separate plugins to make sure that the resources delivered to customers contained only the required dependencies for the project (for example, the production plugins should not depend on Window Tester test harness plugins). 

The team decides that they will run automated checkin tests before each checkin. More specifically, the automated tests to be run will reflect the tets for the modules. For example, if a change is made to module A, then the module A checkin tests will be run. 

But if module B depends on module A, then module B is a downstream dependency on module A. The teams decide that, in addition to the API tests module A might run on checkin, a subset of the module B checkin tests will be run as integration tests for each checkin. Since A cannot depend on B (which would introduce a dependency cycle), how will the module B tests be added to the module A checkin TestSuite? There are a few options:
  # Build a TestSuite in B that includes tests from A. This is undesirable because a) now the module A checkin TestSuite must be maintained outside of module B and b) this solution doesn't scale as the number of modules grows larger.
  # Build a common test plugin that contains one, giant, TestSuite. This solution is undesirable because this all-containing test plugin must depend on every plugin in order to run the tests. In that case, module A's developers would then have to import module B to get the test plugin to compile and modularity is lost.
  # Have everyone run all of the tests, all the time. But what about extended performance tests? Will a developer really want to run a 5-day uptime and memory test for each check in? No...
  # Use Eclipse's plugin loaders and extension points to your advantage. Create a way to flag certain tests with keys and run a test that builds a TestSuite from tests marked with those keywords. This is the TestSuiteBuilder.

=TestSuiteBuilder Components=

There are three parts to TestSuiteBuidler:
  # *The org.wtc.eclipse.tsb.TestSuiteBuilder Class*: The TestSuitebuilder class extends junit.framework.TestCase and so is run directly when running tests. This class is not meant to be subclassed. The tests added to its suite do not have any requirements over the requirements for building JUnit tests (TestCases, TestSuites, etc), though when run with the Helper Libraries, it is best to extend [http://wt-commons.googlecode.com/svn/docs/html/reference/javadoc/helper-libs/org/wtc/eclipse/platform/tests/EclipseUITest.html org.wtc.eclipse.platform.tests.EclipseUITest] and [http://wt-commons.googlecode.com/svn/docs/html/reference/javadoc/helper-libs/org/wtc/eclipse/core/tests/ManagedTestSuite.html org.wtc.eclipse.core.tests.ManagedTestSuite], respectively.
  # *The org.wtc.eclipse.core.testSuiteBuilder Extension Point*: This extension point is declares test registry files for a plugin and is loaded by the TestSuiteBuidler class at runtime. A DTD for this extension is shown below.  NOTE: testSuiteBuilder/registry/@path is a plugin-relative path to a test registry XML file. See the testSuiteBuidler extension point [http://code.google.com/p/wt-commons/source/browse/trunk/helper-libs/eclipse33/plugins/org.wtc.eclipse.core/schema/testSuiteBuilder.exsd source] for more details.
  # *The Test Registry XML File*: This file declares the test classes that a plugin can contribute and the modules, or keywords, that those tests are associated with. A DTD is shown below. NOTE: test-project/test/@class is the fully-qualified class name of a JUnit test to run. This class may be a TestCase or TestSuite (TestDecorators are not supported at this time). The test-project/test/module value is any alpha-numeric string. See [http://code.google.com/p/wt-commons/source/browse/trunk/helper-libs/eclipse33/plugins/org.wtc.eclipse.core/schema/testproject.xsd testProject.xsd] for more information.

===DTD For org.wtc.eclipse.core.testSuiteBuilder Extension Point===
{{{
<!ELEMENT testSuiteBuilder (registry)+ >
<!ELEMENT registry >
<!ATTLIST registry
    path CDATA #REQURIED 
>
}}}

===DTD Test Registry XML File===
{{{
<!ELEMENT test-project (test)* >
<!ELEMENT test (module)+ >
<!ATTLIST test
   class CDATA #REQUIRED
   owner CDATA #IMPLIED
>
<!ELEMENT module #PCDATA>
}}}